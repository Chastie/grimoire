reify is a macro with the following structure:(reify options* specs*)Currently there are no options.Each spec consists of the protocol or interface name followed by zeroor more method bodies:protocol-or-interface-or-Object(methodName [args+] body)*Methods should be supplied for all methods of the desiredprotocol(s) and interface(s). You can also define overrides formethods of Object. Note that the first parameter must be supplied tocorrespond to the target object ('this' in Java parlance). Thusmethods for interfaces will take one more argument than do theinterface declarations.  Note also that recur calls to the methodhead should *not* pass the target object, it will be suppliedautomatically and can not be substituted.The return type can be indicated by a type hint on the method name,and arg types can be indicated by a type hint on arg names. If youleave out all hints, reify will try to match on same name/aritymethod in the protocol(s)/interface(s) - this is preferred. If yousupply any hints at all, no inference is done, so all hints (ordefault of Object) must be correct, for both arguments and returntype. If a method is overloaded in a protocol/interface, multipleindependent method definitions must be supplied.  If overloaded withsame arity in an interface you must specify complete hints todisambiguate - a missing hint implies Object.recur works to method heads The method bodies of reify are lexicalclosures, and can refer to the surrounding local scope:(str (let [f "foo"] (reify Object (toString [this] f))))== "foo"(seq (let [f "foo"] (reify clojure.lang.Seqable (seq [this] (seq f)))))== (\f \o \o))reify always implements clojure.lang.IObj and transfers metadata of the form to the created object.(meta ^{:k :v} (reify Object (toString [this] "foo")))== {:k :v}