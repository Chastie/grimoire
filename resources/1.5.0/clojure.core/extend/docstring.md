Implementations of protocol methods can be provided using the extend construct:(extend ATypeAProtocol{:foo an-existing-fn:bar (fn [a b] ...):baz (fn ([a]...) ([a b] ...)...)}BProtocol {...} ...)extend takes a type/class (or interface, see below), and one or moreprotocol + method map pairs. It will extend the polymorphism of theprotocol's methods to call the supplied methods when an AType isprovided as the first argument. Method maps are maps of the keyword-ized method names to ordinaryfns. This facilitates easy reuse of existing fns and fn maps, forcode reuse/mixins without derivation or composition. You can extendan interface to a protocol. This is primarily to facilitate interopwith the host (e.g. Java) but opens the door to incidental multipleinheritance of implementation since a class can inherit from morethan one interface, both of which extend the protocol. It is TBD howto specify which impl to use. You can extend a protocol on nil.If you are supplying the definitions explicitly (i.e. not reusingexsting functions or mixin maps), you may find it more convenient touse the extend-type or extend-protocol macros.Note that multiple independent extend clauses can exist for the sametype, not all protocols need be defined in a single extend call.See also:extends?, satisfies?, extenders