(deftype name [fields*]  options* specs*)Currently there are no options.Each spec consists of a protocol or interface name followed by zeroor more method bodies:protocol-or-interface-or-Object(methodName [args*] body)*Dynamically generates compiled bytecode for class with the givenname, in a package with the same name as the current namespace, thegiven fields, and, optionally, methods for protocols and/orinterfaces. The class will have the (by default, immutable) fields named byfields, which can have type hints. Protocols/interfaces and methodsare optional. The only methods that can be supplied are thosedeclared in the protocols/interfaces.  Note that method bodies arenot closures, the local environment includes only the named fields,and those fields can be accessed directy. Fields can be qualifiedwith the metadata :volatile-mutable true or :unsynchronized-mutabletrue, at which point (set! afield aval) will be supported in methodbodies. Note well that mutable fields are extremely difficult to usecorrectly, and are present only to facilitate the building of higherlevel constructs, such as Clojure's reference types, in Clojureitself. They are for experts only - if the semantics andimplications of :volatile-mutable or :unsynchronized-mutable are notimmediately apparent to you, you should not be using them.Method definitions take the form:(methodname [args*] body)The argument and return types can be hinted on the arg andmethodname symbols. If not supplied, they will be inferred, so typehints should be reserved for disambiguation.Methods should be supplied for all methods of the desiredprotocol(s) and interface(s). You can also define overrides formethods of Object. Note that a parameter must be supplied tocorrespond to the target object ('this' in Java parlance). Thusmethods for interfaces will take one more argument than do theinterface declarations. Note also that recur calls to the methodhead should *not* pass the target object, it will be suppliedautomatically and can not be substituted.In the method bodies, the (unqualified) name can be used to name theclass (for calls to new, instance? etc).When AOT compiling, generates compiled bytecode for a class with thegiven name (a symbol), prepends the current ns as the package, andwrites the .class file to the *compile-path* directory.One constructor will be defined, taking the designated fields.  Notethat the field names __meta and __extmap are currently reserved andshould not be used when defining your own types.Given (deftype TypeName ...), a factory function called ->TypeNamewill be defined, taking positional parameters for the fields